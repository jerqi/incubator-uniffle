package com.tencent.rss.test.utils;

import java.util.List;
import java.util.Random;
import org.apache.spark.util.LongAccumulator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import scala.Tuple2;
import scala.collection.AbstractIterator;

public class KeyValueGenerator extends AbstractIterator<Tuple2<String, String>> {

  private static final Logger LOG = LoggerFactory.getLogger(KeyValueGenerator.class);

  private long startTime = 0L;
  private Random random = new Random();
  private long currentBytes = 0L;
  private long lastLogTime = 0L;
  private long lastLogBytes = 0L;

  private int mapId;
  private List<String> testValues;
  private long totalBytes;
  private LongAccumulator bytesAccumulator;
  private LongAccumulator recordsAccumulator;

  public KeyValueGenerator(int mapId, List<String> testValues, long totalBytes,
      LongAccumulator bytesAccumulator, LongAccumulator recordsAccumulator) {
    this.mapId = mapId;
    this.testValues = testValues;
    if (totalBytes == -1) {
      this.totalBytes = 1024L * 1024L;
    } else {
      this.totalBytes = totalBytes;
    }

    if (bytesAccumulator == null) {
      this.bytesAccumulator = new LongAccumulator();
    } else {
      this.bytesAccumulator = bytesAccumulator;
    }

    if (recordsAccumulator == null) {
      this.recordsAccumulator = new LongAccumulator();
    } else {
      this.recordsAccumulator = recordsAccumulator;
    }
  }

  @Override
  public boolean hasNext() {
    if (startTime == 0) {
      startTime = System.currentTimeMillis();
    }

    boolean result = currentBytes < totalBytes;
    if (currentBytes < totalBytes) {
      LOG.info("MapId: " + mapId + " finished generating data");
      logStatus();
    }
    return result;
  }

  @Override
  public Tuple2<String, String> next() {
    if (System.currentTimeMillis() - lastLogTime > 30000) {
      logStatus();
    }

    String key = testValues.get(random.nextInt(testValues.size()));
    String value = testValues.get(random.nextInt(testValues.size()));
    currentBytes = currentBytes + key.length() + value.length();
    bytesAccumulator.add(key.length() + value.length());
    recordsAccumulator.add(1);
    return new Tuple2<>(key, value);
  }

  public void logStatus() {
    long progress = 0;
    if (totalBytes == 0) {
      progress = 100;
    } else {
      progress = Math.min(currentBytes, totalBytes) * 100 / totalBytes;
    }
    long duration = System.currentTimeMillis() - lastLogTime;
    String throughput = "";
    if (duration == 0) {
      throughput = "(unknown)";
    } else {
      throughput = (currentBytes - lastLogBytes) * 1.0 / (1024 * 1024) / (duration * 1.0 / 1000.0) + " mb/s";
    }
    LOG.info("MapId: " + mapId + ", generated bytes: " + currentBytes
        + ", progress: " + progress + "%, throughput: " + throughput);
    lastLogTime = System.currentTimeMillis();
    lastLogBytes = currentBytes;
  }
}
